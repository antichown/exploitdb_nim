import locks
import strutils
import httpclient
import threadpool
import times
import os
import sequtils
import asyncdispatch

type
  HTTPSocket* = object 
    path*: string
    cve*: string

var
  lock: Lock
  hosts: seq[string]
  hSocket: HTTPSocket
  thr: seq[Thread[HTTPSocket]]
  thread: Thread[HTTPSocket]
  maxThreads* = 100
  timeout* = 1500 

proc result(text: string) =
  let f = open("result.txt", fmAppend)
  defer: f.close()

  f.writeLine(text)

proc green(text: string) =
  acquire(lock)
  echo "\e[32m", text, "\e[0m"
  result(text)
  release(lock)

proc white(text: string) =
  acquire(lock)
  echo "\e[90m", text, "\e[0m"
  release(lock)

proc http_get(path: cstring,cvex:string) {.async.} =
  try:
    let client = newAsyncHttpClient()
    let response= await client.get($path)
    let code=response.code
    if code==Http200:
      green($path&" "&response.status& " Exploit=https://www.exploit-db.com/exploits/"&cvex.replace(".php","").replace(".html","").replace(".txt","").replace(".pl",""))
    else:
      white($path&" "&response.status)
  except:
    let a="5"


proc httprun_thread(httprun: HTTPSocket) {.thread.} =
    var
        host = httprun.path
        cvex= httprun.cve

    waitFor http_get(host,cvex)

proc first_runner(url:string,file:string)=
  initLock(lock)

  let f = open(file)
  for line in f.readAll().split("\n"):
    hosts.add(line)

  for i in 1..maxThreads:
    thr.add(thread)

  for host in hosts:
    block retry_block:
      while true:
          for i in low(thr)..high(thr):
              if not thr[i].running:
                let cvex=host.split("0x94")[0]
                let httpreq = HTTPSocket(path: url&host.replace(cvex,"").replace("0x94",""),cve:cvex)    
                createThread(thr[i], httprun_thread, httpreq)
                #sleep(100)
                break retry_block
  thr.joinThreads()

proc main() =
  if paramCount()==2:
    first_runner(paramStr(1),paramStr(2))
  else:
    echo "Missing parameter" 

main()
